<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>Haskellの楽しみ：&lt;br&gt;手続き操作型というパラダイム</title><meta charset="utf-8"><script src="unisys-tech-2011-11-09_files/slides.txt"></script><link rel="stylesheet" href="unisys-tech-2011-11-09_files/syntax.css"><link rel="stylesheet" href="unisys-tech-2011-11-09_files/style.css"><meta content="width=1100,height=750" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"></head><body class="loaded" style="display: none;"><section class="slides layout-regular template-pfi"><article class=""><h1>Haskellの楽しみ：<br>手続き操作型というパラダイム</h1><p>田中英行&nbsp;<a href="mailto:tanakh@preferred.jp" alt="">tanakh@preferred.jp</a><br>2011/11/09&nbsp;技術交流会&nbsp;@日本ユニシス</p></article><article class=""><h3>自己紹介</h3><div style="position:absolute; top:375px; left:650px;"><img src="unisys-tech-2011-11-09_files/lyah.png" alt="" class="centered"></div>
<ul><li>田中英行&nbsp;(@tanakh)</li><li>(株)Preferred&nbsp;Infrastracture&nbsp;研究開発部門<ul><li>社内ライブラリ&nbsp;<em>pficommon</em>&nbsp;<br>&nbsp;<a href="https://github.com/pfi/pficommon" alt="">https://github.com/pfi/pficommon</a></li><li>分散機械学習フレームワーク&nbsp;<em>jubatus</em>&nbsp;<br>&nbsp;<a href="http://jubat.us/" alt="">http://jubat.us/</a></li></ul></li><li>Haskell愛好家<ul><li>2003～</li></ul></li><li>Learn&nbsp;You&nbsp;a&nbsp;Haskell&nbsp;for&nbsp;Great&nbsp;Good!<ul><li>訳してます</li></ul></li></ul></article><article class=""><h3>本日の概要</h3><br><p>・&nbsp;Haskellは&nbsp;<strong>簡単</strong></p><p>・&nbsp;Haskellは&nbsp;<strong>すごい</strong></p><p>・&nbsp;Haskellは&nbsp;<strong>面白い</strong></p><br><div class="build"><p class="">・&nbsp;Haskell&nbsp;は簡単ですごく面白い</p><p class="">・&nbsp;Haskell&nbsp;は面白くてすごいものが簡単に作れる</p><p class=""><br>（あとモナドの話少し）</p></div>
</article><article class=""><h2>最近のHaskellの話題</h2></article><article class=""><h3>Yesod</h3><ul><li><a href="http://www.yesodweb.com/" alt="">http://www.yesodweb.com/</a></li><li><p>Webフレームワーク</p></li><li><p>速い！&nbsp;安全！&nbsp;使いやすい！</p></li></ul><p><img src="unisys-tech-2011-11-09_files/header.png" alt="" class="centered"></p></article><article class=""><h3>scalable-server</h3><ul><li><a href="http://hackage.haskell.org/package/scalable-server" alt="">http://hackage.haskell.org/package/scalable-server</a></li><li>スケーラブルなサーバを超簡単に書けるライブラリ<ul><li>I/O&nbsp;全て隠蔽</li><li>非同期隠蔽</li><li>軽量スレッド</li></ul></li><li><a href="http://hackage.haskell.org/package/attoparsec" alt="">attoparsec</a>&nbsp;+&nbsp;<a href="http://hackage.haskell.org/package/enumerator" alt="">enumerator</a>&nbsp;+&nbsp;<a href="http://hackage.haskell.org/package/blaze-builder" alt="">blaze-builder</a>&nbsp;+&nbsp;<a href="http://hackage.haskell.org/package/text" alt="">text</a>&nbsp;+<br>&nbsp;GHC's&nbsp;Scalable&nbsp;I/O&nbsp;manager</li></ul><div align="center"><strong>no&nbsp;more&nbsp;event-driven!</strong></div>
</article><article class=""><h3>angel</h3><ul><li><p>Haskellによる<a href="http://cr.yp.to/daemontools.html" alt="">daemontools</a>の再実装</p></li><li><a href="http://bu.mp/" alt="">bump</a>&nbsp;というサービスの運用に利用されているらしい<ul><li>世界で1千万以上のユーザ&nbsp;+&nbsp;1年以上無停止</li></ul></li></ul><p><img src="unisys-tech-2011-11-09_files/handswithdrawings.png" alt="" class="centered"></p></article><article class=""><h3>pandoc</h3><ul><li><p>汎用ドキュメントコンバータ</p></li><li>HTML,&nbsp;LaTex,&nbsp;Markdown,&nbsp;reST,&nbsp;PDF,&nbsp;epub,&nbsp;...</li><li><p>非常にシンプルなドキュメント型</p></li></ul><br><ul><li>このプレゼンもpandocで作られています<ul><li>markdown&nbsp;=&gt;&nbsp;Pandoc&nbsp;=&gt;&nbsp;HTML5&nbsp;Slide</li><li><a href="file:///C:/Users/tanakh/Dropbox/draft/unisys-haskell/unisys-tech-2011-11-09.md" alt="">ソース</a>ご参照</li></ul></li></ul></article><article class=""><h3>attoparsec</h3><ul><li>高速・シンプルなパーザライブラリ</li></ul></article><article class=""><h3>acid-state</h3><ul><li>ACIDを保証するデータ永続化ライブラリ</li></ul></article><article class=""><h3>shakespeare</h3><ul><li>Hamletなど準クオート群</li></ul>
<pre class="noprettyprint sourceCode"><code class="sourceCode haskell"><span class="ot"><span class="pln">main </span></span><span class="ot"><span class="pun">::</span></span><span class="pln"> </span><span class="dt"><span class="pln">IO</span></span><span class="pln"> </span><span class="pun">()</span><br><span class="pln">main </span><span class="fu"><span class="pun">=</span></span><br><span class="pln">    </span><span class="fu"><span class="pln">writeFile</span></span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> </span><span class="st"><span class="str">"test3.xml"</span></span><span class="pln"> </span><span class="fu"><span class="pln">$</span></span><span class="pln"> </span><span class="dt"><span class="typ">Document</span></span><span class="pln"> </span><span class="pun">(</span><span class="dt"><span class="typ">Prologue</span></span><span class="pln"> </span><span class="pun">[]</span><span class="pln"> </span><span class="kw"><span class="typ">Nothing</span></span><span class="pln"> </span><span class="pun">[])</span><span class="pln"> root </span><span class="pun">[]</span><br><span class="pln">  </span><span class="kw"><span class="kwd">where</span></span><br><span class="pln">    root </span><span class="fu"><span class="pun">=</span></span><span class="pln"> </span><span class="dt"><span class="typ">Element</span></span><span class="pln"> </span><span class="st"><span class="str">"html"</span></span><span class="pln"> </span><span class="pun">[]</span><span class="pln"> </span><span class="pun">[</span><span class="pln">xml</span><span class="fu"><span class="pun">|</span></span><br><span class="fu"><span class="str">&lt;</span></span><span class="fu"><span class="str">head</span></span><span class="fu"><span class="str">&gt;</span></span><br><span class="pln">    </span><span class="fu"><span class="str">&lt;</span></span><span class="str">title</span><span class="fu"><span class="str">&gt;</span></span><br><span class="pln">        </span><span class="dt"><span class="typ">My</span></span><span class="pln"> </span><span class="fu"><span class="com">#</span></span><br><span class="pln">        </span><span class="fu"><span class="str">&lt;</span></span><span class="str">b</span><span class="fu"><span class="str">&gt;</span></span><span class="dt"><span class="typ">Title</span></span><br><span class="fu"><span class="str">&lt;</span></span><span class="str">body</span><span class="fu"><span class="str">&gt;</span></span><br><span class="pln">    </span><span class="fu"><span class="str">&lt;</span></span><span class="str">p</span><span class="fu"><span class="str">&gt;</span></span><span class="pln">foo bar baz</span><br><span class="fu"><span class="pun">|</span></span><span class="pun">]</span></code></pre>
</article><article class=""><h3>Configurator</h3><ul><li>設定ファイル読み込みライブラリ<ul><li>自動変更監視</li><li>変更通知</li></ul></li></ul></article><article class=""><h2>Haskellの楽しみ</h2></article><article class=""><h3>よくある誤解</h3><ul><li>Haskellは&nbsp;<strong>難しい</strong></li><li>難しいことが簡単に&nbsp;簡単なことが&nbsp;<strong>難しく</strong></li><li>I/O&nbsp;が&nbsp;<strong>苦手</strong></li><li>強い型付けは&nbsp;<strong>面倒</strong></li></ul></article><article class=""><h3>今日は</h3><ul><li>遅延評価</li><li>参照透明</li></ul><p>のことは一旦忘れてください</p><br><p>ことさらに取りざたされますが、これはあまり重要じゃない（と思います）です</p></article><article class=""><h3>Haskellは&nbsp;<strong>難しくない</strong></h3><ul><li>C++</li></ul>
<pre class="noprettyprint sourceCode"><code class="sourceCode cpp"><span class="ot"><span class="com">#include</span><span class="pln"> </span></span><span class="ot"><span class="str">&lt;iostream&gt;</span></span><br><span class="dt"><span class="kwd">int</span></span><span class="pln"> main</span><span class="pun">()</span><br><span class="pun">{</span><br><span class="pln">  std</span><span class="pun">::</span><span class="pln">cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="st"><span class="str">"Hello, World!"</span></span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> std</span><span class="pun">::</span><span class="pln">endl</span><span class="pun">;</span><br><span class="pln">  </span><span class="kw"><span class="kwd">return</span></span><span class="pln"> </span><span class="dv"><span class="lit">0</span></span><span class="pun">;</span><br><span class="pun">}</span></code></pre>
</article><article class=""><h3>Haskellは&nbsp;<strong>難しくない</strong></h3><ul><li>Java</li></ul>
<pre class="noprettyprint sourceCode"><code class="sourceCode java"><span class="kw"><span class="kwd">public</span></span><span class="pln"> </span><span class="kw"><span class="kwd">class</span></span><span class="pln"> </span><span class="typ">Main</span><span class="pln"> </span><span class="pun">{</span><br><span class="pln">  </span><span class="kw"><span class="kwd">public</span></span><span class="pln"> </span><span class="dt"><span class="kwd">static</span></span><span class="pln"> </span><span class="dt"><span class="kwd">void</span></span><span class="pln"> </span><span class="fu"><span class="pln">main</span></span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><br><span class="pln">    </span><span class="typ">System</span><span class="pun">.</span><span class="fu"><span class="kwd">out</span></span><span class="pun">.</span><span class="fu"><span class="pln">println</span></span><span class="pun">(</span><span class="st"><span class="str">"Hello, World!"</span></span><span class="pun">);</span><br><span class="pln">  </span><span class="pun">}</span><br><span class="pun">}</span></code></pre>
</article><article class=""><h3>Haskellは&nbsp;<strong>難しくない</strong></h3><ul><li>Haskell</li></ul>
<pre class="noprettyprint sourceCode"><code class="sourceCode haskell"><span class="pln">main </span><span class="fu"><span class="pun">=</span></span><span class="pln"> </span><span class="fu"><span class="pln">putStrLn</span></span><span class="pln"> </span><span class="st"><span class="str">"Hello, World!"</span></span></code></pre>
</article><article class=""><h3>I/Oが苦手？</h3><ul><li>IOモナドは扱いにくいか？<ul><li>そんなことはない</li></ul></li><li>記述上のデメリットはもう殆ど無いといえる<ul><li>do&nbsp;構文が便利</li><li>Aplicativeスタイルが便利</li></ul></li><li>IO処理を値として使える<ul><li>その他もろもろのモナド変換子、モナドリフタ…</li><li>むしろ他の言語よりIOが柔軟に行える</li><li>SimonPJ曰く、"Haskellはもっとも美しい手続き型言語"</li></ul></li></ul></article><article class=""><h3>なんとなくそういう印象を受ける</h3><ul><li>参照透明な言語でコードを書いたことがない</li><li>モナドを利用したコードを書いたことがない</li></ul><p>経験の問題！まずはコードを書いてみましょう</p></article><article class=""><h3>型付けは安心のため</h3><ul><li>型はエラーを防ぐ</li><li>型は良いドキュメントになる</li></ul><p>⇒&nbsp;初めて使うライブラリでも安心して使える</p></article><article class=""><h3>型は面倒ではない</h3><ul><li>Hindley-Milner型推論<ul><li><a href="http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner" alt="">http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner</a></li></ul></li><li>大部分の型を処理系が自力で見つける<ul><li>変数</li><li>関数の引数</li><li>型クラス…</li></ul></li></ul>
<pre class="noprettyprint sourceCode"><code class="sourceCode haskell"><span class="co"><span class="pun">--</span><span class="pln"> foo </span><span class="pun">::</span><span class="pln"> </span><span class="typ">Num</span><span class="pln"> a </span><span class="pun">=&gt;</span><span class="pln"> a </span><span class="pun">-&gt;</span><span class="pln"> a</span></span><br><span class="pln">foo n </span><span class="fu"><span class="pun">=</span></span><span class="pln"> n </span><span class="fu"><span class="pun">+</span></span><span class="pln"> </span><span class="dv"><span class="lit">1</span></span></code></pre>
</article><article class=""><h3>型は役に立たない？</h3><p>Java&nbsp;1.4</p>
<pre class="noprettyprint sourceCode"><code class="sourceCode java"><span class="kw"><span class="kwd">class</span></span><span class="pln"> </span><span class="typ">Hoge</span><span class="pln"> </span><span class="pun">{</span><br><span class="pln">  </span><span class="kw"><span class="kwd">public</span></span><span class="pln"> </span><span class="dt"><span class="kwd">static</span></span><span class="pln"> </span><span class="dt"><span class="kwd">void</span></span><span class="pln"> </span><span class="fu"><span class="pln">main</span></span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><br><span class="pln">    </span><span class="typ">List</span><span class="pln"> l</span><span class="pun">;</span><br><span class="pln">    l</span><span class="pun">.</span><span class="fu"><span class="pln">add</span></span><span class="pun">(</span><span class="st"><span class="str">"string"</span></span><span class="pun">);</span><br><span class="pln">    </span><span class="typ">Integet</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Integer</span><span class="pun">)</span><span class="pln">l</span><span class="pun">.</span><span class="fu"><span class="pln">indexOf</span></span><span class="pun">(</span><span class="dv"><span class="lit">0</span></span><span class="pun">);</span><span class="pln"> </span><span class="co"><span class="com">// Oops...</span></span><br><span class="pln">  </span><span class="pun">}</span><br><span class="pun">}</span></code></pre>
</article><article class=""><h3>型は役に立たない？</h3><p>Java&nbsp;1.5</p>
<pre class="noprettyprint sourceCode"><code class="sourceCode java"><span class="kw"><span class="kwd">class</span></span><span class="pln"> </span><span class="typ">Hoge</span><span class="pln"> </span><span class="pun">{</span><br><span class="pln">  </span><span class="kw"><span class="kwd">public</span></span><span class="pln"> </span><span class="dt"><span class="kwd">static</span></span><span class="pln"> </span><span class="dt"><span class="kwd">void</span></span><span class="pln"> </span><span class="fu"><span class="pln">main</span></span><span class="pun">(</span><span class="typ">String</span><span class="pun">[]</span><span class="pln"> args</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><br><span class="pln">    </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;</span><span class="pln"> l</span><span class="pun">;</span><br><span class="pln">    l</span><span class="pun">.</span><span class="fu"><span class="pln">add</span></span><span class="pun">(</span><span class="st"><span class="str">"string"</span></span><span class="pun">);</span><br><span class="pln">    </span><span class="typ">Integet</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> l</span><span class="pun">.</span><span class="fu"><span class="pln">indexOf</span></span><span class="pun">(</span><span class="dv"><span class="lit">0</span></span><span class="pun">);</span><span class="pln"> </span><span class="co"><span class="com">// Compile Error :)</span></span><br><span class="pln">  </span><span class="pun">}</span><br><span class="pun">}</span></code></pre>
<p>型システムの有用性は型システムの表現力に左右される</p></article><article class=""><h3>Haskellの型システム</h3><ul><li><p>Haskellの型システムは、広く利用可能な言語の中で、最も強力・かつ扱いやすい部類</p></li><li>型システムのいろいろは&nbsp;Lambda&nbsp;Cube&nbsp;とかで熟知すべし<ul><li><a href="http://en.wikipedia.org/wiki/Lambda_cube" alt="">http://en.wikipedia.org/wiki/Lambda_cube</a></li></ul></li><li><p><a href="http://www.cis.upenn.edu/%7Ebcpierce/tapl/" alt="">Types&nbsp;and&nbsp;Programming&nbsp;Languages</a>&nbsp;などの書籍も</p></li></ul></article><article class=""><h3>Haskellの型に特徴的な機能</h3><ul><li>Type&nbsp;Class</li><li>Rank-N-Polymorphism</li><li>GADTs</li><li>Type&nbsp;Families</li></ul><p>とにかく強力！</p></article><article class=""><h2>モナド：手続き操作型というパラダイム</h2></article><article class=""><h3>モナドに関する疑問</h3><ul><li>モナドとは何か？</li><li>モナドをどう使うか？</li><li>モナドをどう作るか？</li><li><em>なぜ</em>&nbsp;モナドなのか？</li></ul></article><article class=""><h3>こちらもご参照ください</h3><div style="width:780px" id="__ss_9290002"><iframe src="http://www.slideshare.net/slideshow/embed_code/9290002" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" height="355" width="425"></iframe> <div style="padding:5px 0 12px"> View&nbsp;more&nbsp;<a href="http://www.slideshare.net/" target="_blank">presentations</a>&nbsp;from&nbsp;<a href="http://www.slideshare.net/tanakh" target="_blank">tanakh</a></div> </div>
</article><article class=""><h3>モナドとはどういうものか？</h3><ul><li>設計手法の１つ？</li><li>デザインパターンの１つ？</li></ul></article><article class=""><h3>モナドはパラダイムである</h3><ul><li>応用範囲が広い<ul><li>濫用じゃないのかと思った時期もありました</li></ul></li><li>特定の問題を解決するものではない<ul><li>何にでも使えるという事実（後述）</li></ul></li><li>⇒&nbsp;<strong>パラダイム</strong>&nbsp;である！<ul><li>オブジェクト指向のオブジェクトのように、まずモナドありきで考えるべきもの</li></ul></li></ul></article><article class=""><h3>モナドとは何か？</h3><ul><li>計算のコンテクスト<ul><li>それがどう言う計算を表すか</li><li>床下配線のアナロジー</li></ul></li><li>モナド＝コンテクストの総称<ul><li>コンテクストの抽象化ができる</li></ul></li><li>⇒&nbsp;コンテクストに対する抽象化を行うのが、まずひとつのモナドを使う理由</li></ul></article><article class=""><h3>例</h3><p>Intを返す&nbsp;<strong>何らか</strong>&nbsp;の計算</p>
<pre class="noprettyprint sourceCode"><code class="sourceCode haskell"><span class="ot"><span class="pln">foo </span></span><span class="ot"><span class="pun">::</span></span><span class="pln"> </span><span class="kw"><span class="typ">Monad</span></span><span class="pln"> m </span><span class="ot"><span class="pun">=&gt;</span></span><span class="pln"> m </span><span class="dt"><span class="typ">Int</span></span><br><span class="pln">foo </span><span class="fu"><span class="pun">=</span></span><span class="pln"> </span><span class="fu"><span class="kwd">return</span></span><span class="pln"> </span><span class="dv"><span class="lit">1</span></span></code></pre>
<p>Intの状態を持ちBoolを返す&nbsp;<strong>何らか</strong>&nbsp;の計算</p>
<pre class="noprettyprint sourceCode"><code class="sourceCode haskell"><span class="ot"><span class="pln">bar </span></span><span class="ot"><span class="pun">::</span></span><span class="pln"> </span><span class="dt"><span class="typ">MonadState</span></span><span class="pln"> </span><span class="dt"><span class="typ">Int</span></span><span class="pln"> m </span><span class="ot"><span class="pun">=&gt;</span></span><span class="pln"> m </span><span class="dt"><span class="typ">Bool</span></span><br><span class="pln">bar </span><span class="fu"><span class="pun">=</span></span><span class="pln"> </span><span class="kw"><span class="kwd">do</span></span><br><span class="pln">  state </span><span class="ot"><span class="pun">&lt;-</span></span><span class="pln"> </span><span class="kwd">get</span><br><span class="pln">  </span><span class="fu"><span class="kwd">return</span></span><span class="pln"> </span><span class="fu"><span class="pln">$</span></span><span class="pln"> state </span><span class="fu"><span class="pun">==</span></span><span class="pln"> </span><span class="dv"><span class="lit">0</span></span></code></pre>
<p>(コンテクストに対してポリモーフィックなことに注意)</p></article><article class=""><h3>モナドのコンテクストの具体例</h3><ul><li>非決定計算<ul><li>List</li></ul></li><li>例外処理・エラー処理<ul><li>Maybe,&nbsp;Either,&nbsp;MonadError,&nbsp;MonadFailure</li></ul></li><li>継続・限定継続<ul><li>MonadCont</li></ul></li><li>メモ化<ul><li>MonadMemo</li></ul></li><li>並行・並列計算<ul><li>Parモナド、STMモナドなど</li></ul></li><li>分散計算<ul><li>CloudHaskell</li></ul></li></ul></article><article class=""><h3>なぜ、モナドなのか？</h3><ul><li><p>モナドで充分だから</p></li><li>モナドはチューリング完全である<ul><li>構造化定理の3つの構造が記述できる</li></ul></li><li>構造化定理<ul><li>逐次：&nbsp;２つの処理を順番に実行する</li><li>反復：&nbsp;条件の満たされる間処理を繰り返す</li><li>分岐：&nbsp;条件により分岐する</li></ul></li></ul></article><article class=""><h3>モナドで十分な理由</h3><ul><li>あちら側（モナド）とこちら側（ホスト言語：Haskell）をシームレスに繋げる</li></ul>
<pre class="noprettyprint sourceCode"><code class="sourceCode haskell"><span class="pln">main </span><span class="fu"><span class="pun">=</span></span><span class="pln"> </span><span class="kw"><span class="kwd">do</span></span><br><span class="pln">  line </span><span class="ot"><span class="pun">&lt;-</span></span><span class="pln"> </span><span class="fu"><span class="pln">getLine</span></span><span class="pln">   </span><span class="co"><span class="pun">--</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> </span><span class="str">'Monads value'</span></span><br><span class="pln">  </span><span class="kw"><span class="kwd">if</span></span><span class="pln"> line </span><span class="fu"><span class="pun">==</span></span><span class="pln"> </span><span class="st"><span class="str">""</span></span><span class="pln">     </span><span class="co"><span class="pun">--</span><span class="pln"> depend of its value</span><span class="pun">...</span></span><br><span class="pln">    </span><span class="kw"><span class="kwd">then</span></span><span class="pln"> </span><span class="fu"><span class="kwd">return</span></span><span class="pln"> </span><span class="pun">()</span><br><span class="pln">    </span><span class="kw"><span class="kwd">else</span></span><span class="pln"> </span><span class="kw"><span class="kwd">do</span></span><span class="pln">         </span><span class="co"><span class="pun">--</span><span class="pln"> changes the built monad</span></span><br><span class="pln">      </span><span class="fu"><span class="pln">putStrLn</span></span><span class="pln"> line</span><br><span class="pln">      main</span></code></pre>
<ul><li>これはまさにメタプログラミングを実行時の情報を用いて行っている<ul><li>メタメタプログラミングとでも言うべきもの</li></ul></li></ul></article><article class=""><h3>モナドから見た命令型</h3><ul><li><p>計算コンテクストの1つに過ぎない</p></li><li>その他：<ul><li>論理型</li><li>オブジェクト指向</li><li>アスペクト,&nbsp;etc…</li></ul></li></ul><br><ul><li>これらはモナドのコンテクストとして実装できる</li></ul></article><article class=""><h3>モナドはパラダイムを抽象化するもの</h3><ul><li><p>では、モナドはなんなのか？</p><ul><li>⇒&nbsp;メタパラダイム</li></ul></li><li><p>IOモナド（手続き型コンテクスト）を用いるHaskell</p><ul><li>⇒&nbsp;<strong>手続き操作型パラダイム</strong></li></ul></li></ul><p><br>&nbsp;（という命名を思いつきました）</p></article><article class=""><h3>IO&nbsp;モナドの正体</h3><ul><li>所謂Cなどの命令型言語のコンテクスト一式のパック<ul><li>逐次実行</li><li>メモリの読み書き</li><li>入出力</li></ul></li><li>HaskellがCでできることの全てかつCとのリンクをできることを保証するためのFallback</li></ul></article><article class=""><h3>MonadIO</h3><ul><li>そこのコンテクストに、IOを埋め込めることを保証<ul><li>つまりどこでもなんでもできることを保証</li></ul></li><li>IOモナドを避けつつ、どこでもprintfデバッグできるので便利</li></ul></article><article class=""><h3>MonadControlIO</h3><ul><li>IOにそのコンテクストを渡す事ができるのを保証<ul><li><em>bracket&nbsp;::&nbsp;IO&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;b)&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;IO&nbsp;c)&nbsp;-&gt;&nbsp;IO&nbsp;c</em>&nbsp;とか</li></ul></li><li>安全な例外処理を実装するために必要</li></ul></article><article class=""><h3>Identityモナド</h3><ul><li>何のコンテクストも持たない（追加しない）モナド</li><li>Haskellのセマンティクスそのもの</li></ul></article><article class=""><h3>モナドを扱う言語で望ましいこと</h3><ul><li>Identityモナドがなるべくプレーンなコンテクストであるのが望ましい<ul><li>コンテクストの追加はできても除去はできないため</li></ul></li><li>遅延評価<ul><li>モナドの評価は遅延されなければならない（後述）</li></ul></li><li>一方、純粋関数型言語<ul><li>副作用なし</li><li>遅延評価</li></ul></li></ul></article><article class="far-past"><h3>モナドと遅延評価</h3><p>モナドが再帰している例：</p>
<pre class="noprettyprint sourceCode"><code class="sourceCode haskell"><span class="pln">rep p </span><span class="fu"><span class="pun">=</span></span><span class="pln"> p </span><span class="fu"><span class="pun">&gt;&gt;</span></span><span class="pln"> rep p </span><span class="fu"><span class="pun">&lt;|&gt;</span></span><span class="pln"> mempty</span></code></pre>
<p>遅延評価じゃなければ…</p>
<pre class="noprettyprint sourceCode"><code class="sourceCode haskell"><span class="pln">rep p </span><span class="fu"><span class="pun">=</span></span><span class="pln"> </span><span class="pun">(</span><span class="pln">\_ </span><span class="ot"><span class="pun">-&gt;</span></span><span class="pln"> p </span><span class="fu"><span class="pun">&gt;&gt;</span></span><span class="pln"> rep p </span><span class="pun">()</span><span class="pln"> </span><span class="fu"><span class="pun">&lt;|&gt;</span></span><span class="pln"> mempty</span><span class="pun">)</span></code></pre>
<p>一段クロージャに包む必要がある<br>&nbsp;（これでも遅延評価と同じとは行かない）</p></article><article class="past"><h3>モナドでのプログラミング</h3><ul><li>まず、やりたい計算がどういうものか考える<ul><li>具体的にどういう計算かを考えるのではなくて、どういうコンテクストを持つのか</li><li>状態を持つ、並列制御がいる、エラー処理が必要、etc...</li><li>この時に全てのことを考える必要はない</li><li>モナド変換子で後からコンテクストを足すことができる</li></ul></li><li>それからモナドを作る<ul><li>床下の配線を書く</li><li>抽象化できるならモナドクラスにする</li></ul></li><li>それからアプリを書く<ul><li>大抵のものはありあわせのモナドの組み合わせでなんとかなるので、ここからスタートできる</li></ul></li></ul></article><article class="current"><h3>まとめ</h3><ul><li>Haskellコミュニティは急速に活性化している</li><li>高速・堅牢・安全・簡潔&nbsp;を支えるインフラが充実</li><li>モナドの使われ方も成熟してきた</li><li>⇒&nbsp;Haskellは現場言語へ！</li></ul><p><img src="unisys-tech-2011-11-09_files/images.jpg" alt="" class="centered"></p><div align="center"><strong><em>Happy&nbsp;Haskelling!</em></strong></div>







</article><div id="prev-slide-area" class="slide-area"></div><div id="next-slide-area" class="slide-area"></div></section><link href="unisys-tech-2011-11-09_files/css.css" type="text/css" rel="stylesheet"><link href="unisys-tech-2011-11-09_files/styles.css" type="text/css" rel="stylesheet"><script src="unisys-tech-2011-11-09_files/prettify.txt" type="text/javascript"></script></body></html>
