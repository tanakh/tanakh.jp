<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>foldlを直す - 純粋関数空間</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../css/bootstrap.min.css" rel="stylesheet" media="screen">
    <link href="../css/bootstrap-responsive.min.css" rel="stylesheet" media="screen">
    <link href="../css/default.css" rel="stylesheet" media="screen">
    <link href="../css/syntax.css" rel="stylesheet" media="screen">
    <link href="../css/docs.css" rel="stylesheet" media="screen">

    <script type="text/javascript" src="http://s.hatena.ne.jp/js/HatenaStar.js"></script>
    <script type="text/javascript">
        Hatena.Star.Token = '448676af7a3fe5b6511e9789fbaed5a26da61054';
        Hatena.Star.SiteConfig = {
            entryNodes: {
                '.post-title': {
                    uri: 'document.location',
                    title: 'document.title',
                    container: 'parent'
                }
            }
        };
    </script>
  </head>
  <body>
    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="../js/bootstrap.min.js"></script>

    <div class="container-fluid">
        <div class="navbar">
            <div class="navbar-inner">
                <a class="brand" href="../">tanakh.jp</a>

                <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </a>

                <div class="nav-collapse">
                    <ul class="nav">
                        <li><a href="../">Home</a></li>
                        <li><a href="../about.html">About</a></li>
                        <li><a href="../contact.html">Contact</a></li>
                        <li><a href="../pub.html">Publications</a></li>
                        <li><a href="../tools.html">Tools</a></li>
                        <li><a href="../archive.html">Archive</a></li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="row-fluid">
            <div class="span2"></div>
            <div class="span8">
                <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<h2 class="post-title">foldlを直す</h2>

<p>
  <div class="info">Posted on April  7, 2014, Tags: <a href="../tags/haskell.html">Haskell</a></div>
</p>

<!-- Social Buttons -->
<div class="social">
    <div class="hatena">
        <a href="http://b.hatena.ne.jp/entry/tanakh.jp/posts/2014-04-07-foldl-is-broken.html" class="hatena-bookmark-button" data-hatena-bookmark-title="foldlを直す - tanakh.jp" data-hatena-bookmark-layout="standard-balloon" title="このエントリーをはてなブックマークに追加"><img src="http://b.st-hatena.com/images/entry-button/button-only.gif" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="http://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    </div>
    <div class="facebook">
        <div class="fb-like" data-href="http://tanakh.jp/posts/2014-04-07-foldl-is-broken.html" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" data-font="arial"></div>
    </div>
    <div class="gplus">
        <!-- +1 ボタン を表示したい位置に次のタグを貼り付けてください。 -->
        <div class="g-plusone" data-size="medium" data-href="http://tanakh.jp/posts/2014-04-07-foldl-is-broken.html"></div>
        <!-- 最後の +1 ボタン タグの後に次のタグを貼り付けてください。 -->
        <script type="text/javascript">
          (function() {
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
            po.src = 'https://apis.google.com/js/plusone.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
          })();
        </script>
    </div>
    <div class="twitter">
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="tanakh" data-lang="ja">ツイート</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    </div>
</div>

<hr>

<div class="post-content">
<p><a href="http://www.well-typed.com/blog/90/" class="uri">http://www.well-typed.com/blog/90/</a></p>
<p><code>foldl</code>に関するこの記事（英文）が面白かったので、勝手翻訳しました。 <code>foldl</code>なんとかなるといいですね。</p>
<hr />
<h2 id="foldlを直す">foldlを直す</h2>
<p><code>foldl</code> 関数は壊れている。壊れているとみんなが知っている。 四半世紀近く壊れたままだ。ついにこれを修正する時が来た！</p>
<p>今日、私は<code>Prelude.foldl</code>を<code>Data.List.foldl'</code>として知られる実装で再定義することを提案する。</p>
<h2 id="foldlは壊れている">foldlは壊れている！</h2>
<p>既にご存知だとは思うが、念のため…</p>
<p>Haskellerが必ず<code>foldl</code>ではなく、<code>foldr</code>や<code>foldl'</code>を使うように勧めてくることにお気づきだろうか？ 例えばReal World Haskellでは次のように言っている。</p>
<pre><code>`foldl`のサンクの挙動のため、実アプリではこの関数を使わないようにするのが望ましい。
特に問題がない場合でも、`foldl`の使用は不要なオーバーヘッドを払うことになる。
代わりに`Data.List`をインポートして、`foldl'`を使うこと。</code></pre>
<p>この本のオンライン版の最初のユーザーコメントは次のようなものだった。</p>
<pre><code>なんでData.Listのfoldlの実装がPreludeにないんですか？</code></pre>
<p>　</p>
<pre><code>追加：なんで`foldl'`がデフォルトじゃないんですか？</code></pre>
<p>いい質問だ。</p>
<p>OK、それじゃあ<code>foldl</code>と<code>foldl'</code>の違いを話さねばならない。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl<span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldl f a []     <span class="fu">=</span> a
foldl f a (x<span class="fu">:</span>xs) <span class="fu">=</span> foldl f (f a x) xs

<span class="ot">foldl' ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldl' f a []     <span class="fu">=</span> a
foldl' f a (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">let</span> a' <span class="fu">=</span> f a x <span class="kw">in</span> a' <span class="ot">`seq`</span> foldl' f a' xs</code></pre>
<p>無味乾燥な技術的な違いは、<code>foldl'</code>は次の再帰呼び出しの前に関数呼び出しを評価するというところだ。 その結果どういう違いが起こるのかはおそらく自明ではないので、 もう少し広い範囲を眺めてみることにしよう。</p>
<h2 id="右畳み込み左畳み込み">右畳み込み、左畳み込み</h2>
<p>最初にHaskellを勉強したとき、リストの畳み込み方には右からと左からの二つがあると教わったはずだ。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl f z [x1, x2, <span class="fu">...</span>, xn] <span class="fu">=</span> (<span class="fu">...</span>((z <span class="ot">`f`</span> x1) <span class="ot">`f`</span> x2) <span class="ot">`f`</span><span class="fu">...</span>) <span class="ot">`f`</span> xn

foldr f z [x1, x2, <span class="fu">...</span>, xn] <span class="fu">=</span> x1 <span class="ot">`f`</span> (x2 <span class="ot">`f`</span> <span class="fu">...</span> (xn <span class="ot">`f`</span> z)<span class="fu">...</span>)</code></pre>
<p>「左から」あるいは「右から」というのは、<code>foldl</code>と<code>foldr</code>が計算するもの、 括弧が左にネストしているか、右にネストしているか、を表している。 実行時にはもちろんリストは左（先頭）の要素から見なければならない。</p>
<p>それから、左右の畳み込みについて違った考え方を勉強することになる。 すなわち、左畳み込みはリスト全体を正格に走査する伝統的なループとして使えて、 右畳み込みはデマンドドリブンなイテレータとして使えるということだ。 左畳み込みをこのように使うケースでは、第1引数に対して正格な関数（例えば<code>(+)</code>）を渡し、 右畳み込みでは第2引数に対して非正格な関数（例えば<code>(:)</code>）を渡す。</p>
<p>実際には<code>foldl</code>と<code>foldr</code>のどちらを使うべきなのかは、 「すべての要素を一度」必要とする(<code>foldl</code>)か、 インクリメンタルな、あるいはショートカットの振る舞いが必要か(<code>foldr</code>)によって決めることが多い。</p>
<h2 id="アキュームレータのサンク">アキュームレータのサンク</h2>
<p>これまたHaskellの勉強にて、foldlは次のような頭のおかしい挙動をするのだと教わる。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl (<span class="fu">+</span>) <span class="dv">0</span> (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>[])
          <span class="fu">=</span>  foldl (<span class="fu">+</span>) (<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>)             (<span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>[])
          <span class="fu">=</span>  foldl (<span class="fu">+</span>) ((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>)       (<span class="dv">3</span><span class="fu">:</span>[])
          <span class="fu">=</span>  foldl (<span class="fu">+</span>) (((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span>) []
          <span class="fu">=</span>            (((<span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span>)</code></pre>
<p>ループとして利用する際、こういうことに気を付けなければならない。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl' (<span class="fu">+</span>) <span class="dv">0</span> (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>[])
          <span class="fu">=</span>  foldl' (<span class="fu">+</span>) <span class="dv">1</span> (<span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>[])
          <span class="fu">=</span>  foldl' (<span class="fu">+</span>) <span class="dv">3</span> (<span class="dv">3</span><span class="fu">:</span>[])
          <span class="fu">=</span>  foldl' (<span class="fu">+</span>) <span class="dv">6</span> []
          <span class="fu">=</span>             <span class="dv">6</span></code></pre>
<p>もちろんこれは<code>foldl'</code>で解決できる。 <code>foldl'</code>では`<code>+</code>の呼び出しは次の再帰呼び出しの前に評価される。</p>
<h2 id="どういう時にfoldlではなくfoldlが役に立つのか">どういう時に(foldl’ではなく)foldlが役に立つのか？</h2>
<p>短い答えは「そんなことはまずない」である。</p>
<p>初心者は、往々にして<code>foldl</code>は何らかの意味のある場合があるのだ （でなければ、何で両方あるんだ？）と思い込むものだが、 実際にはそんなケースはないのだとだんだん分かってくる。</p>
<p>まず<code>foldl</code>の引数<code>f</code>が正格関数だった時、 この場合いずれにせよ最後まで評価しなければならないので、 評価の遅延には全く何の意味もない。 なので、何かご利益があるとすれば関数<code>f</code>の第1引数が非正格な時に限られるが、 それも考えなくてもよい。 なぜなら、普通はまず<code>foldr</code>が第一候補に挙がるからである。</p>
<p>実際には、関数<code>f</code>の第1引数が非正格であるときでさえ、 おそらく評価の遅延は何の利得も生まないし、 先行評価することによる害もないだろう。 <code>foldl</code>はリスト全体を走査する必要があることを思い出して欲しい。 <code>foldr</code>のショートカット動作は<code>foldl</code>では不可能なのだ。</p>
<p><code>foldl'</code>が過剰に正格だということを示す作為的な例は、作ろうと思えば作れる。 <code>last</code>と<code>last'</code>を次のように定義する。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">last  <span class="fu">=</span> foldl  (\_ y <span class="ot">-&gt;</span> y) (error <span class="st">&quot;empty list&quot;</span>)

last' <span class="fu">=</span> foldl' (\_ y <span class="ot">-&gt;</span> y) (error <span class="st">&quot;empty list&quot;</span>)</code></pre>
<p>これを試してみるとこうなる。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> last [<span class="dv">1</span>,undefined,<span class="dv">3</span>]
<span class="dv">3</span>
<span class="fu">&gt;</span> last' [<span class="dv">1</span>,undefined,<span class="dv">3</span>]
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.undefined</code></pre>
<p>これはアキュームレータが常に最後の要素になるが、 （最後の一つ以外の）要素は実際には必要としないためである。</p>
<p>そういうわけで、<code>foldl'</code>がこういうケースで失敗するのは確かだが、 この例はまた、頭の悪い実装でもある。 普通の定義の方がよほどわかりやすい。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">last [x]    <span class="fu">=</span> x
last (_<span class="fu">:</span>xs) <span class="fu">=</span> last xs
last []     <span class="fu">=</span> error <span class="st">&quot;empty list&quot;</span></code></pre>
<p><code>foldl</code>でうまく行って<code>foldl'</code>ではだめなケースはすべてこうした方がうまく書ける。 つまりそういう例は、作為的なものであるか、あるいは別の書き方をした方が分かりやすい。</p>
<p>時々<code>sum</code>が<code>foldl'</code>ではなく<code>foldl</code>で定義されていることを、 これはHaskellの設計者が<code>(+)</code>が遅延であるような<code>Num</code>のインスタンスを許したいが為の 要求なのだと指摘する人がいる。 全くもってナンセンスである。 そもそもそういうケースではショートカット動作の恩恵を受けるために、 <code>foldl</code>ではなくて<code>foldr</code>を使うべきである。 もっと分かりやすく言えば、<code>sum</code>が定義されたころの初期のバージョンのHaskellには <code>foldl'</code>が用意されていなかったということだ。</p>
<p>Haskellプログラマとしての15年近くの間に、 明確に<code>foldl'</code>ではなくて<code>foldl</code>を使う必要があると思ったこと場面が3回ぐらいある。 なぜ正確な回数じゃないのかといえば、正確に思い出せるのがそのうちの1回だけだからである。 その1回が、Webサーバーのキャッシュをアップデートするためのこの <a href="https://github.com/haskell/hackage-server/blob/1dcb855ca962ff89b550153f940c66a88e228509/Distribution/Server/Util/AsyncVar.hs#L28">小汚いコード</a>である。 ローカル再帰で書いた方がどう考えても綺麗になるはずだが、 その時の私は<code>foldl</code>の実利用を思いついた嬉しさのあまりに、 それを使うことを止められなかった。 もちろん間違って<code>foldl</code>を使っているわけではないことを示すためにコメントが必要だった。</p>
<h2 id="それではなぜfoldlとfoldlがあるのか">それでは、なぜfoldlとfoldl’があるのか？</h2>
<p><code>foldl</code>がほぼ間違いなく間違いである（あるいは、良性の問題である）というのなら、 どうして第一候補に鎮座しているのだろう。</p>
<p>確かなことは分からないが、私の推測を書いてみよう…</p>
<p>遡ること24年前、Haskell 1.0の発表の日、 当時<code>seq</code>関数のようなものは影も形もなく、 それゆえ、<code>foldl</code>を「古典的」に定義する以外、選択肢がそもそも存在しなかった。</p>
<p>時は流れ6年後、多くの議論を経てHaskell 1.3に<code>seq</code>関数が入ることになる。 しかしながらHaskell 1.3の<code>seq</code>関数は<code>Eval</code>クラスの一部だったので、どこでも使えるというわけではなかった。 Haskell 1.3では、<code>foldl'</code>は次のような型で定義しなければならなかっただろう。</p>
<pre><code>foldl' :: Eval b =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></pre>
<p>Haskell 1.4とHaskell 98は<code>seq</code>から<code>Eval</code>クラスの制約を外すことになったが、 <code>foldl</code>の定義は変わらなかった。 そこでHugsとGHC、その他の処理系は非標準の<code>foldl'</code>を追加した。</p>
<p>当時の人々は互換性の問題を考えるのが面倒だと考えたのではなかろうか。 非標準の<code>foldl'</code>を追加することは簡単だが、標準を変えることはそれほどには簡単ではない。</p>
<p>最初から<code>seq</code>が有ったのならば、<code>foldl</code>はそれを使って実装されたのではなかろうか。</p>
<p>MirandaというHaskellの祖先の1つには、Haskell 1.0の5年も前から既に<code>seq</code>が存在していた。</p>
<h2 id="orwellの正格foldl">Orwellの正格foldl！</h2>
<p>Orwellは興味深い例だ。 Orwellはまた別のHaskellの祖先であり、 Mirandaおよび初期のHaskellに非常によく似ている。 消息筋によれば、Orwellの<code>foldl</code>は今日<code>foldl'</code>として定義されるもの、すなわち正格評価版だったそうだ。 私はそれを確かめるため、数日オンラインをさまよったが、 Orwellに関する情報は非常に少なかったため、 Philip Wadlerに直接尋ねることにした。 Philは親切にも、私の為にマニュアルを発掘して問題の定義の部分を見つけてくれた。</p>
<p>オリジナルバージョンでは、</p>
<pre><code>An Introduction to Orwell
(DRAFT)
Philip Wadler
1 April 1985
In the standard prelude:

lred f a []  =  a
lred f a (x:xs) = lred f (f a x) xs</code></pre>
<p>このように定義されていたが、5年後、Haskell 1.0が公開されるという頃…</p>
<pre><code>An Introduction to Orwell 6.00
by Philip Wadler
revised by Quentin Miller
Copyright 1990 Oxford University Computing Lab

In the standard prelude:

foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
foldl f a []  =  a
foldl f a (x:xs)  =  strict (foldl f) (f a x) xs</code></pre>
<p><code>strict</code>という関数が使われているところに注目したい。 おそらく、Orwellの<code>strict</code>関数は次のように（あるいはそれと等価に）定義されていたのだろう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">strict ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
strict f x <span class="fu">=</span> x <span class="ot">`seq`</span> f x</code></pre>
<p>（これは近頃のHaskellでは<code>($!)</code>と呼ばれているものだ。）</p>
<p>つまり、私の情報が正しいのならば、Orwellは<code>foldl</code>を正格なバージョンに変更したということだ！</p>
<p>私はこれが正しい決定「だった」と、そして正しい決定「である」と主張する。 <code>foldl</code>が修正されなかったのは、単にHaskellへの<code>seq</code>の実装の遅れと、 後方互換性への恐れ及び怠慢が招いた結果に過ぎないのだと主張する。</p>
<h2 id="just-do-it">Just do it!</h2>
<p><code>foldl</code>の修正は<code>Data.List</code>のimportに煩わされて、 ついうっかり出来心で<code>foldl</code>を使ってしまう我々の助けになるだろう。 また、迷える初心者の助けにもなるはずだ。 さらに、<code>foldl</code>を最初に説明して、なぜそれを決して使ってはならないのか教えなければならない 講師の救いにもなるはずだ。</p>
<p>Orwellはこの過ちを24年前に修正した。 おそらくHaskell 1.0よりも前のことだ。 単なる古い間違いなのだから、 今我々がこれを直さない理由はどこにもない！</p>
<h2 id="後書きどっちのfoldl">後書き：どっちのfoldl’？</h2>
<p>単純な話をややこしくするのは好きではないが、 <code>foldl'</code>の定義としてふさわしいものが2つあることをお断りしておく。 どちらがよりふさわしいのかという真剣な議論を見たことはない （これもまた別の歴史的な事故だと疑っている）。</p>
<p>本文中に引用したバージョンが「標準的な」バージョンである。 bangパターンを用いて、もう少し綺麗に書くことができる。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldl' ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldl' f a []     <span class="fu">=</span> a
foldl' f a (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">let</span> <span class="fu">!</span>a' <span class="fu">=</span> f a x
                     <span class="kw">in</span> foldl' f a' xs</code></pre>
<p>もう一つのバージョンは次の通り。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldl'' ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldl'' f <span class="fu">!</span>a []     <span class="fu">=</span> a
foldl'' f <span class="fu">!</span>a (x<span class="fu">:</span>xs) <span class="fu">=</span> foldl'' f (f a x) xs</code></pre>
<p>一つ目のバージョンは、再帰呼び出しの前にアキュームレータを評価するのに対して、 二つ目のバージョンは呼び出しに際して、アキュームレータを常に（WHNFまで） 評価した状態にしておくという違いがある。</p>
<p>これらの二つは<strong>ほとんど</strong>同じ挙動を示す。 異なる結果になる入力を見つけるのはちょっと手間だが、ここに一つを示す。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl'  (\_ y <span class="ot">-&gt;</span> y) undefined [<span class="dv">1</span>] <span class="fu">=</span> <span class="dv">1</span>
foldl'' (\_ y <span class="ot">-&gt;</span> y) undefined [<span class="dv">1</span>] <span class="fu">=</span> undefined</code></pre>
<p>標準的な<code>foldl'</code>は、すべての<strong>新しく作った</strong>アキュームレータを評価されるようにするが、 最初に渡された値は依然として評価しなくてもよい。 別のバージョンでは、アキュームレータは常に評価されることが伺える。</p>
<p>二つ目のバージョンは、コード生成という観点からは魅力的である。 GHCが<code>foldl'</code>に対して（そして正格関数を渡されたときに）行える賢い最適化の一つに値のunbox化があり、 これにより例えば<code>Int</code>を<code>Int#</code>にunboxして、引数をヒープではなくレジスタで渡すことができる。 標準的なバージョンの<code>foldl'</code>では、ループの初回のみ、特別ケースとして扱わなければならない。 なぜならば、アキュームレータがまだ評価されていないかもしれないからである。 <code>foldl''</code>ではそういう心配はない。 最初のイテレーションから正しくunbox化できる。 もっとも、GHCは大抵の場合は初期値が常に評価されるかどうかを推論することができるが、常にではない。</p>
<p>（Don Stewartと私は数年前、リストのstream fusionの作業中にこれに気づいた。 ストリームに対する<code>foldl'</code>を二つ目のバージョンに対応する形で実装して、 そして、標準リスト関数との正格性の比較テストの実行中に失敗した。）</p>
<p>そういうわけで、<code>foldl</code>を正格バージョンに修正しようとするなら、 「最初のイテレーション以降を正格に」バージョンではなく、 完全正格バージョンにするべきかもしれない。</p>
</div>

<br>

<script type="text/javascript"><!--
google_ad_client = "ca-pub-2554934724722249";
/* normal */
google_ad_slot = "6131209617";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

<br>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'tanakh-jp'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'tanakh-jp'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

            </div>
            <div class="span2"></div>
        </div>

        <hr>

        <footer class="footer">
            <center>
            <p>
                Copyright (c) 2011-2015, Hideyuki Tanaka (@<a href="https://twitter.com/tanakh">tanakh</a>)
            </p>
            <p>
                Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.<br>
                Served by <a href="http://mew.org/~kazu/proj/mighttpd/en/">Mighttpd2</a>.<br>
                Tools are made with <a href="http://fay-lang.org/">Fay</a>.<br>
                This site uses <a href="http://twitter.github.io/bootstrap/">Twitter Bootstrap</a>, and theme from <a href="http://bootswatch.com/">Bootswatch</a>.<br>
            <p>
            </center>
        </footer>
    </div>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26679036-1']);
      _gaq.push(['_setDomainName', 'tanakh.jp']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>

  </body>
</html>
