<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>ConduitとHaskellでネットワークプロキシサーバを作る - 純粋関数空間</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../css/bootstrap.min.css" rel="stylesheet" media="screen">
    <link href="../css/bootstrap-responsive.min.css" rel="stylesheet" media="screen">
    <link href="../css/default.css" rel="stylesheet" media="screen">
    <link href="../css/syntax.css" rel="stylesheet" media="screen">
    <link href="../css/docs.css" rel="stylesheet" media="screen">

    <script type="text/javascript" src="http://s.hatena.ne.jp/js/HatenaStar.js"></script>
    <script type="text/javascript">
        Hatena.Star.Token = '448676af7a3fe5b6511e9789fbaed5a26da61054';
        Hatena.Star.SiteConfig = {
            entryNodes: {
                '.post-title': {
                    uri: 'document.location',
                    title: 'document.title',
                    container: 'parent'
                }
            }
        };
    </script>
  </head>
  <body>
    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="../js/bootstrap.min.js"></script>

    <div class="container-fluid">
        <div class="navbar">
            <div class="navbar-inner">
                <a class="brand" href="../">tanakh.jp</a>

                <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </a>

                <div class="nav-collapse">
                    <ul class="nav">
                        <li><a href="../">Home</a></li>
                        <li><a href="../about.html">About</a></li>
                        <li><a href="../contact.html">Contact</a></li>
                        <li><a href="../pub.html">Publications</a></li>
                        <li><a href="../tools.html">Tools</a></li>
                        <li><a href="../archive.html">Archive</a></li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="row-fluid">
            <div class="span2"></div>
            <div class="span8">
                <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

<h2 class="post-title">ConduitとHaskellでネットワークプロキシサーバを作る</h2>

<p>
  <div class="info">Posted on July  1, 2012, Tags: <a href="../tags/haskell.html">Haskell</a></div>
</p>

<!-- Social Buttons -->
<div class="social">
    <div class="hatena">
        <a href="http://b.hatena.ne.jp/entry/tanakh.jp/posts/2012-07-01-conduit-0.5.html" class="hatena-bookmark-button" data-hatena-bookmark-title="ConduitとHaskellでネットワークプロキシサーバを作る - tanakh.jp" data-hatena-bookmark-layout="standard-balloon" title="このエントリーをはてなブックマークに追加"><img src="http://b.st-hatena.com/images/entry-button/button-only.gif" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="http://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    </div>
    <div class="facebook">
        <div class="fb-like" data-href="http://tanakh.jp/posts/2012-07-01-conduit-0.5.html" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false" data-font="arial"></div>
    </div>
    <div class="gplus">
        <!-- +1 ボタン を表示したい位置に次のタグを貼り付けてください。 -->
        <div class="g-plusone" data-size="medium" data-href="http://tanakh.jp/posts/2012-07-01-conduit-0.5.html"></div>
        <!-- 最後の +1 ボタン タグの後に次のタグを貼り付けてください。 -->
        <script type="text/javascript">
          (function() {
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
            po.src = 'https://apis.google.com/js/plusone.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
          })();
        </script>
    </div>
    <div class="twitter">
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="tanakh" data-lang="ja">ツイート</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    </div>
</div>

<hr>

<div class="post-content">
<p>この記事は <a href="http://www.yesodweb.com/blog/2012/06/conduit-0-5" class="uri">http://www.yesodweb.com/blog/2012/06/conduit-0-5</a> の翻訳です。</p>
<hr />
<p><a href="http://hackage.haskell.org/package/conduit-0.5.0">conduit-0.5</a> をリリースしました。 <code>conduit</code>はストリームデータを扱うためのライブラリです。 <code>conduit</code>を用いると、様々な形のデータを生成、変形、消費するような処理を、 簡単に組み合わせることができるようになります。 <code>enumerator</code>/<code>iteratee</code>パラダイムと同じ問題を解決することを目的に作られましたが、 アプローチはこれらのものとは異なります。 <code>conduit</code>は簡単に理解して利用できるものになることを一番の目的としています。 遅延I/Oとは異なり、リソースの即時開放を保証し、 また、純粋なコードに例外を持ち込みません。</p>
<p>今回のリリースで<code>Source</code>、<code>Sink</code>、<code>Conduit</code>のそれぞれを作るための、 シンプルで効率の良い、高レベルのインターフェースが提供されるようになりました。 コンストラクタ（Haskellのデータコンストラクタ）をダイレクトに用いる必要は もう殆どなくなったはずです。 床下（訳注：Conduitの持つ機能のこと）には、 上流の結果を受け取ったり、<code>Leftover</code>（訳注：データの食い残し）を明示的に無視するといった、 より強力な機能が組み込まれました。 これらの変更は、Conduitを<code>Category</code>(訳注：圏を表す<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Category.html">Haskellの型クラス</a>) として振る舞うことを可能にします（訳注：今のところ実装はされていない模様）。</p>
<p>新しいバージョンでは、 ひと通りのチュートリアルが<a href="http://hackage.haskell.org/packages/archive/conduit/0.5.0/doc/html/Data-Conduit.html">Haddock</a>自身に含まれています。 使い始めるにあたっては、まずこれを読むのをお勧めします。 以前のバージョンのConduitを使ったことがある人も、 このチュートリアルを読めば以前と変わった部分がはっきりすると思います （finalizationの動作の詳細とか）。</p>
<p>最後に一つ注意。このリリースには<code>conduit</code>とそのデフォルト付属パッケージ、 <code>attoparsec-conduit</code>や<code>zlib-conduit</code>しか含まれていません。 <code>wai</code>, <code>parsistent</code>, <code>yesod</code>あるいはもっといろいろな古いconduitに依存したパッケージは含まれません。 それらは十分にテストしてリリース準備が整い次第リリースされる予定です。 <strong>これらの問題や、リリースについての質問をGithubのIssueに挙げないこと。</strong> Yesodチームがリリースの準備が十分にできたと判断した時に、リリースは行われます。</p>
<p>この記事の残りの部分で、<code>conduit</code>の使い方の洗練された例を紹介します。 ネットワークサーバの作成についての <a href="http://www.haskell.org/pipermail/haskell-cafe/2012-June/102008.html">MLでの質問</a> がベースになっています。</p>
<hr />
<p><a href="http://hackage.haskell.org/package/network-conduit">network-conduit</a> はネットワークサーバとクライアントを作るための高レベルのライブラリです。 基本的なサンプルから、違うアプリケーションを作っていきます。 まず、次のコードから始めましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Conduit</span>
<span class="kw">import </span><span class="dt">Data.Conduit.Network</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runTCPServer (<span class="dt">ServerSettings</span> <span class="dv">4000</span> <span class="dt">HostAny</span>) app

<span class="ot">app ::</span> <span class="dt">Application</span> <span class="dt">IO</span>
app <span class="fu">=</span> <span class="fu">...</span></code></pre>
<p><code>Application</code>とはなんじゃらホイ？ これはソースとシンクを受け取って、それらに何か処理をする単なる関数です （訳注：<code>Application</code>の型を補足）。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Application</span> m <span class="fu">=</span> <span class="dt">Source</span> m <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Sink</span> <span class="dt">ByteString</span> m () <span class="ot">-&gt;</span> m ()</code></pre>
<p>一番シンプルな例、echoでも実装してみましょうか。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">app src sink <span class="fu">=</span> src <span class="fu">$$$$</span> sink</code></pre>
<p>ここで必要になるのは、ソースとシンクをつなぐことだけ。 あとは<code>conduit</code>が全部面倒を見てくれます。 受け取ったデータは即座に正しくシンクに送られます。 ここには明示的なループがないこと、 中間データを触るコードがないこと、 そして、終了についての明示的なコードが無いこと。 これらに注意されたい。</p>
<blockquote>
<p>訳注： TCPサーバのオプションにはポート番号とホストの設定以外含まれていないが、 これで十分実用的なのである。 このTCPサーバは完全に並行にリクエストを処理する実装になる。 つまり接続ごとに独立したスレッドが作られる。 Haskellのスレッドは非常に軽量で、スレッドを一つ作るコストは オブジェクトをひとつ作るコストと大して変わらない。 したがって、サーバオプションとしての並行度の指定は必要がない。 タイムアウトの設定も必要ない。 Haskellのスレッドは（FFIなどを使わない限り）いつでも安全にキャンセルできる。 標準が提供するI/Oライブラリはすべてキャンセル可能なAPIの呼び出しによって行われる。 つまりタイムアウトが必要であれば <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-Timeout.html">System.Timeout</a> を使えばよい。</p>
</blockquote>
<p>これはあまりにもつまらない例ですね。 エコーバックする際に大文字化するものでも書いてみましょう。 このタスクに必要となるものを列挙します。 まず最初に、バイナリをテキストデータにデコードする必要があります （ascii文字列を仮定することによってこれをインチキすることもできるけど、 それは正しくも楽しくもないので、ちゃんとやることにします）。 次に1文字ずつ大文字に変換します。 最後に、文字データをバイナリに再エンコードして出力に送ります。</p>
<p>幾つか追加の<code>import</code>が必要になります。 で、これがそのコードです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Conduit.List</span> <span class="kw">as</span> <span class="dt">CL</span>
<span class="kw">import </span><span class="dt">Data.Conduit.Text</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (toUpper)

app src sink <span class="fu">=</span> src
            <span class="fu">$$$$</span> decode utf8
            <span class="fu">=$</span> CL.map toUpper
            <span class="fu">=$</span> encode utf8
            <span class="fu">=$</span> sink</code></pre>
<p>なんという宣言的なアプローチでしょう。 上で列挙した各ステップが、 次のステップにつながれているだけ！</p>
<p>別の例を考えましょう。 受け取った各チャンクに対して、そのサイズを表示します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">S8</span>
app src sink <span class="fu">=</span> src
            <span class="fu">$$$$</span> CL.map (\bs <span class="ot">-&gt;</span> S8.pack <span class="fu">$</span> show (S8.length bs) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span>)
            <span class="fu">=$</span> sink</code></pre>
<p>なにやらパターンが見えてきました。 ソースとシンクを端において、その間を<code>conduit</code>のパイプラインでつなぐ。 ではその考えを進めて、パターンを抽象化してみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">app src sink <span class="fu">=</span> src <span class="fu">$$$$</span> conduit <span class="fu">=$</span> sink</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">conduit ::</span> <span class="dt">Conduit</span> <span class="dt">ByteString</span> <span class="dt">IO</span> <span class="dt">ByteString</span>
conduit <span class="fu">=</span> CL.map (\bs <span class="ot">-&gt;</span> S8.pack <span class="fu">$</span> show (S8.length bs) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span>)</code></pre>
<p>最初の例だと、こうなります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">conduit <span class="fu">=</span> decode utf8 <span class="fu">=$=</span> CL.map toUpper <span class="fu">=$=</span> encode utf8</code></pre>
<p>さてこうなると、一つ疑問が生じます。 なんで<code>network-conduit</code>はソースとシンクを提供しているのでしょうか？ <code>Application</code>は単に<code>Conduit</code>ではだめなのか？ その答え、ソースとシンクに分けて提供しているのは、 それが<code>Conduit</code>よりも真に強力だからです。 あとで見ていきますが、それによって<code>connect-and-resume</code>のような 強力な機能が実現できます。</p>
<h2 id="制御フロー">制御フロー</h2>
<p>今までの例はどれも無限のパイプライン、 つまり、同じ処理を接続が切れるまで繰り返すものでした。 なにか制御フローを追加してみましょう。 次のコードは先頭に <code>&quot;quit&quot;</code> の4文字が含まれるチャンクを受信するまで、 エコーを繰り返すというものです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">conduit <span class="fu">=</span> <span class="kw">do</span>
    mbs <span class="ot">&lt;-</span> await
    <span class="kw">case</span> mbs <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()
        <span class="dt">Just</span> bs
            <span class="fu">|</span> <span class="st">&quot;quit&quot;</span> <span class="ot">`S8.isPrefixOf`</span> bs <span class="ot">-&gt;</span> return ()
            <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> <span class="kw">do</span>
                yield bs
                conduit <span class="co">-- loop</span></code></pre>
<p>単なる無限ループではなく、 明示的に <code>await</code> と <code>yield</code> を読んでデータを読み書きするようになりました。</p>
<h2 id="他のioとインターリーブ">他のI/Oとインターリーブ</h2>
<p>簡単なファイルサーバを作りましょう。 ファイル名を送ると、サーバがそのファイルの内容を返してくるようなものです。 これを行うためには、わずかにプログラムの型を変更する必要があります。 <code>IO</code>モナドの代わりに、<code>ResourceT IO</code>モナドを使うようにします。 そうすれば、例外安全にファイルアクセスができるようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Conduit.Binary</span> <span class="kw">as</span> <span class="dt">CB</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runResourceT <span class="fu">$</span> runTCPServer (<span class="dt">ServerSettings</span> <span class="dv">4000</span> <span class="dt">HostAny</span>) app

<span class="ot">app ::</span> <span class="dt">Application</span> (<span class="dt">ResourceT</span> <span class="dt">IO</span>)
app src sink <span class="fu">=</span> src <span class="fu">$$$$</span> conduit <span class="fu">=$</span> sink

<span class="ot">conduit ::</span> <span class="dt">Conduit</span> <span class="dt">ByteString</span> (<span class="dt">ResourceT</span> <span class="dt">IO</span>) <span class="dt">ByteString</span>
conduit <span class="fu">=</span> CB.lines <span class="fu">=$=</span>
          awaitForever (CB.sourceFile <span class="fu">.</span> S8.unpack <span class="fu">.</span> S8.takeWhile (<span class="fu">/=</span> <span class="ch">'\r'</span>))</code></pre>
<p>ここでは意図的にファイル名のエンコーディングを無視しています。 普通は（訳注：モダンなHaskellコードでは、次のようなイケてる） <a href="http://hackage.haskell.org/package/system-filepath">system-filepath</a>と <a href="http://hackage.haskell.org/package/filesystem-conduit">filesystem-conduit</a>パッケージを使うのだけど、 説明が億劫なので、単にascii文字列としてアンパックしています。 また、<code>Data.Conduit.Binary.lines</code>関数は’\n’しか取り除かないので、 ’\r’を手動で取り除いています。 ほとんどのtelnetクライアントは改行コードとしてCRLFを送信するので、 これを取り除く処理を入れるべきでしょう。</p>
<p><a href="http://hackage.haskell.org/packages/archive/conduit/0.5.0/doc/html/Data-Conduit.html#v:awaitForever"><code>awaitForever</code></a> は 入力がある限り内部の関数を実行する、便利関数です。 もちろん、さっきみたいな“quitアプローチ”と組み合わせての、手動ループ制御もできます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">conduit <span class="fu">=</span>
    CB.lines <span class="fu">=$=</span> loop
  <span class="kw">where</span>
    loop <span class="fu">=</span> <span class="kw">do</span>
        mbs <span class="ot">&lt;-</span> await
        <span class="kw">case</span> mbs <span class="kw">of</span>
            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()
            <span class="dt">Just</span> bs
                <span class="fu">|</span> <span class="st">&quot;quit&quot;</span> <span class="ot">`S8.isPrefixOf`</span> bs <span class="ot">-&gt;</span> return ()
                <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> <span class="kw">do</span>
                    CB.sourceFile <span class="fu">$</span> S8.unpack <span class="fu">$</span> S8.takeWhile (<span class="fu">/=</span> <span class="ch">'\r'</span>) bs
                    loop</code></pre>
<h2 id="クライアントサイド">クライアントサイド</h2>
<p><code>network-conduit</code> には、サーバのインターフェースにとても良く似た、 クライアントのためのインターフェースもあります。 例を見てみます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import </span><span class="dt">Data.Conduit</span>
<span class="kw">import qualified</span> <span class="dt">Data.Conduit.List</span> <span class="kw">as</span> <span class="dt">CL</span>
<span class="kw">import </span><span class="dt">Data.Conduit.Network</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Char8</span> ()

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runTCPClient (<span class="dt">ClientSettings</span> <span class="dv">4000</span> <span class="st">&quot;localhost&quot;</span>) client

<span class="ot">client ::</span> <span class="dt">Application</span> <span class="dt">IO</span>
client src sink <span class="fu">=</span>
    src <span class="fu">$$$$</span> conduit <span class="fu">=$</span> sink
  <span class="kw">where</span>
    conduit <span class="fu">=</span> <span class="kw">do</span>
        yield <span class="st">&quot;hello&quot;</span>
        await <span class="fu">&gt;&gt;=</span> liftIO <span class="fu">.</span> print

        yield <span class="st">&quot;world&quot;</span>
        await <span class="fu">&gt;&gt;=</span> liftIO <span class="fu">.</span> print

        yield <span class="st">&quot;goodbye&quot;</span>
        await <span class="fu">&gt;&gt;=</span> liftIO <span class="fu">.</span> print</code></pre>
<p>ここには特に見所はありません。 このセクションの目的は、最後の例のための準備です。</p>
<h2 id="プロキシサーバ">プロキシサーバ</h2>
<p><code>conduit</code>のモチベーションの一つとして、 HTTPプロキシサーバを作れるようにするというのがあります。 <code>enumerator</code>では、私（訳注：もちろん原文の著者）を含む多くの人が、 ちゃんと動作するプロキシサーバを、 与えられたピースの組み合わせで作るのが とてつもなく難しいということを発見していました （多段にネストしたIterateeを使えば、実際にはできます。でもそれは恐るべき苦痛でもあります）。</p>
<p>じゃあ、簡単なネットワークプロキシサーバを作ってみましょうか。 これは次のように動作します。</p>
<ul>
<li>クライアントが接続する</li>
<li>クライアントはサーバのポート番号を一行で送ってくる</li>
<li>クライアントはサーバのホスト名を一行で送ってくる</li>
<li>プロキシがサーバに接続する</li>
<li>プロキシはクライアントに “Successful connection” と返答する</li>
<li><p>次を繰り返す</p>
<ul>
<li>クライアントはプロキシにチャンクを送る</li>
<li>プロキシは同じチャンクをサーバに送る</li>
<li>サーバはプロキシにチャンクを送る</li>
<li>プロキシはクライアントにそのチャンクを送る</li>
</ul></li>
</ul>
<p>標準のソケットベース（あるいはハンドルベース）の関数を使えば、 これは別にそんなに難しくありません。 2つの別々のソケットに対して、sendとrecvをすれば良いだけです。 ここでのポイントは、自分自身がアプリケーションの実行フローを制御するので、 違うソースを使う処理に簡単にインターリーブできるということです。 Conduit（やEnumerator）は制御フローの面倒を見てもらう代わりに、 インターリーブが難しくなるという、ちょうど逆転が起こるのです。</p>
<p>そこでConduitはコントロールフローをアプリケーションに返す「抜け道」を 用意することにしました。 それが<code>connect-and-resume</code>と呼ばれるものです。 なんだか恐ろしげに聞こえますが、大丈夫、怖くないですよ。 ソースにシンクを接続し、シンクが終了するまで実行して、結果を返します。 ここで、その結果と一緒に新しい <strong>resumable source</strong> を返します。 それから、その<code>resumable source</code>を再度ソースとして使います。 それの繰り返しになります。</p>
<p>最初に、main関数を見ていきましょう。 クライアントからの接続を受け付けます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> forkIO <span class="fu">$</span> runTCPServer (<span class="dt">ServerSettings</span> <span class="dv">5000</span> <span class="dt">HostAny</span>) proxy</code></pre>
<p>プロキシの処理では、ポートとホスト名が必要になります。 次に、そのサーバへ接続します。 一行読み込みを行う関数と、 ポートとホスト名のペアを読み込むヘルパ関数を定義しましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">takeLine <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> linefeed <span class="fu">=</span> <span class="dv">10</span>
    bss <span class="ot">&lt;-</span> CB.takeWhile (<span class="fu">/=</span> linefeed) <span class="fu">=$</span> CL.consume
    CB.drop <span class="dv">1</span> <span class="co">-- drop the newline</span>
    return <span class="fu">$</span> S8.takeWhile (<span class="fu">/=</span> <span class="ch">'\r'</span>) <span class="fu">$</span> S8.concat bss

getPortHost <span class="fu">=</span> <span class="kw">do</span>
    portBS <span class="ot">&lt;-</span> takeLine
    hostBS <span class="ot">&lt;-</span> takeLine
    return <span class="fu">$</span> <span class="dt">ClientSettings</span> (read <span class="fu">$</span> S8.unpack portBS) (S8.unpack hostBS)</code></pre>
<p>次に、<code>connect-and-resume</code> (<code>$$$$+</code> 演算子) を用いて<code>proxy</code>関数を定義しましょう。 ソースをシンク、<code>getPortHost</code>に接続して、クライアントの設定と新しい<code>ResumableSource</code>を受け取ります。 これをリードループ(<code>proxyLoop</code>)に渡します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">proxy ::</span> <span class="dt">Application</span> <span class="dt">IO</span>
proxy fromClient0 toClient <span class="fu">=</span> <span class="kw">do</span>
    (fromClient, clientSettings) <span class="ot">&lt;-</span> fromClient0 <span class="fu">$$$$+</span> getPortHost
    runTCPClient clientSettings (proxyLoop fromClient toClient)</code></pre>
<p><code>proxyLoop</code>からは、まず接続成功メッセージをクライアントに送ります。 サーバから受け取るための<code>ResumableSource</code>を作り、ループを開始します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">proxyLoop fromClient toClient fromServer0 toServer <span class="fu">=</span> <span class="kw">do</span>
    yield <span class="st">&quot;Connected to server&quot;</span> <span class="fu">$$$$</span> toClient
    <span class="co">-- convert fromServer0 from a normal Source to a ResumableSource</span>
    (fromServer, ()) <span class="ot">&lt;-</span> fromServer0 <span class="fu">$$$$+</span> return ()
    loop fromClient fromServer
  <span class="kw">where</span></code></pre>
<p>内部のループは（訳注：ちょっとややこしそうに見えるけど）とても直接的です。 上の4ステップを忠実にこなしているだけです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    loop fromClient fromServer <span class="fu">=</span> <span class="kw">do</span>
        (fromClient', mbs) <span class="ot">&lt;-</span> fromClient <span class="fu">$$$$++</span> await
        <span class="kw">case</span> mbs <span class="kw">of</span>
            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> close fromClient' fromServer
            <span class="dt">Just</span> bs <span class="ot">-&gt;</span> <span class="kw">do</span>
                yield bs <span class="fu">$$$$</span> toServer
                (fromServer', mbs) <span class="ot">&lt;-</span> fromServer <span class="fu">$$$$++</span> await
                <span class="kw">case</span> mbs <span class="kw">of</span>
                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
                        yield <span class="st">&quot;Server closed connection&quot;</span> <span class="fu">$$$$</span> toClient
                        close fromClient' fromServer'
                    <span class="dt">Just</span> bs <span class="ot">-&gt;</span> <span class="kw">do</span>
                        yield bs <span class="fu">$$$$</span> toClient
                        loop fromClient' fromServer'</code></pre>
<p>ここでは2つのトリックが用いられています。 1つ目は、<code>$$$$++</code> 演算子。 これは <code>$$$$+</code> 演算子と同じですが、普通の<code>Source</code>の代わりに すでにある<code>ResumableSource</code>に対して動作します。 “continue resuming”ということです。 2つ目は、<code>close</code> 関数の呼び出し。 普通の<code>Source</code>、<code>Sink</code>を使っているときは、 これらは使い終わると自動的に閉じられ（訳注：リソース解放など）ます。 しかし<code>ResumableSource</code>は、あとでの利用のためにすぐには閉じません。 これを行うためには明示的に閉じてやる必要があります。 これをやるのは簡単です。<code>$$$$+-</code>演算子を使います。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    close x y <span class="fu">=</span> <span class="kw">do</span>
        x <span class="fu">$$$$+-</span> return ()
        y <span class="fu">$$$$+-</span> return ()</code></pre>
<p><code>connect-and-resume</code>は常に必要になるとは限りませんが、 やりたいことが所謂「コーナーケース」にあるような場合には、とても便利に使えます。</p>
<h2 id="完全なソース">完全なソース</h2>
<p><a href="https://gist.github.com/3010975">Gist</a>で完全なソースが見られます。 このチュートリアルが、Conduitの強力さと、その使い方を示す助けになれば幸いです。 何か質問や、こうすべきだという点があれば、ぜひお知らせ願いたい！</p>
<p>ところで、<a href="https://gist.github.com/3010975#gistcomment-360243">Felipeの指摘</a>で、 <code>proxyLoop</code>を、スレッドを用いて実装するというのがありました。 私は<code>connect-and-resume</code>のデモのために、故意に<code>proxyLoop</code>をこのように書きました。 でも、スレッドを用いれば次のようにも実装できます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">proxyLoop fromClient0 toClient fromServer0 toServer <span class="fu">=</span> <span class="kw">do</span>
    yield <span class="st">&quot;Connected to server&quot;</span> <span class="fu">$$$$</span> toClient
    m <span class="ot">&lt;-</span> M.newEmptyMVar
    tid1 <span class="ot">&lt;-</span> forkIO <span class="fu">$</span> <span class="kw">do</span>
        fromServer0 <span class="fu">$$$$</span> toClient
        M.putMVar m <span class="dt">True</span>
    tid2 <span class="ot">&lt;-</span> forkIO <span class="fu">$</span> <span class="kw">do</span>
        fromClient0 <span class="fu">$$$$+-</span> toServer
        M.putMVar m <span class="dt">False</span>
    x <span class="ot">&lt;-</span> M.takeMVar m
    <span class="kw">if</span> x
        <span class="kw">then</span> killThread tid2
        <span class="kw">else</span> killThread tid1</code></pre>
<blockquote>
<p>訳注： 並行処理のための便利なライブラリ <a href="http://hackage.haskell.org/package/async">async</a> を使うと恐ろしくシンプルに。 (サーバのSource -&gt; クライアントのSink) と (クライアントのSource -&gt; サーバのSink) の接続を並行に行うというやりたい処理をまさにそのまま書けてしまった。 全体のソースは<a href="https://gist.github.com/3017519">こちら</a>。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">proxyLoop fromClient0 toClient fromServer0 toServer <span class="fu">=</span> <span class="kw">do</span>
  yield <span class="st">&quot;Connected to server&quot;</span> <span class="fu">$$$$</span> toClient
  (fromServer0 <span class="fu">$$$$</span> toClient) <span class="ot">`race_`</span> (fromClient0 <span class="fu">$$$$+-</span> toServer)</code></pre>
</blockquote>
</div>

<br>

<script type="text/javascript"><!--
google_ad_client = "ca-pub-2554934724722249";
/* normal */
google_ad_slot = "6131209617";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

<br>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'tanakh-jp'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'tanakh-jp'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

            </div>
            <div class="span2"></div>
        </div>

        <hr>

        <footer class="footer">
            <center>
            <p>
                Copyright (c) 2011-2013, Hideyuki Tanaka (@<a href="https://twitter.com/tanakh">tanakh</a>)
            </p>
            <p>
                Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.<br>
                Served by <a href="http://mew.org/~kazu/proj/mighttpd/en/">Mighttpd2</a>.<br>
                Tools are made with <a href="http://fay-lang.org/">Fay</a>.<br>
                This site uses <a href="http://twitter.github.io/bootstrap/">Twitter Bootstrap</a>, and theme from <a href="http://bootswatch.com/">Bootswatch</a>.<br>
            <p>
            </center>
        </footer>
    </div>

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-26679036-1']);
      _gaq.push(['_setDomainName', 'tanakh.jp']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>

  </body>
</html>
